// Script generated by the Inno Setup Script Wizard.
// SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "BeaLink"
#define MyAppVersion "1.9.5"
#define MyAppURL "https://github.com/Brian-Lynn/Bealink"
// 主程序文件名更新 - 确保这是32位编译的 Bealink.exe
#define MyAppExeName "Bealink.exe"
// AppId 保持不变，用于卸载、版本管理和重复安装检测
#define MyAppId "bealink_server"

[Setup]
// NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
AppId={#MyAppId}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
// 移除 ArchitecturesInstallIn64BitMode 使安装程序默认为32位模式
// ArchitecturesAllowed 允许此32位安装程序在32位和64位Windows上运行
ArchitecturesAllowed=x86 x64

//AppVerName={#MyAppName} {#MyAppVersion} // 可选，如果需要显示版本号的完整名称
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
// 用户要求：即使是32位应用，在64位系统上也尝试安装到 Program Files
// 在32位系统上，{commonpf64} 会回退到标准 Program Files
DefaultDirName={commonpf64}\{#MyAppName}
// 开始菜单文件夹名
DefaultGroupName={#MyAppName} Server
// 卸载时显示的图标
UninstallDisplayIcon={app}\{#MyAppExeName}
// 生成的安装包存放目录 (相对于 .iss 文件)
OutputDir=.\OutputInstaller
// 生成的安装包文件名，可以标识为32位或通用
OutputBaseFilename=BeaLink_Installer_v{#MyAppVersion}_32bit
Compression=lzma
SolidCompression=yes
// SetupIconFile 指向与 .iss 文件同目录的 icon.ico
SetupIconFile=icon.ico
WizardStyle=modern

[Languages]
// 确保 Inno Setup 的 Languages 目录已配置好，或者 .isl 文件在指定路径
Name: "chinesesimplified"; MessagesFile: "compiler:Languages\ChineseSimplified.isl"

[Tasks]
// 开机自启任务，默认不勾选，让用户选择
Name: "autoStart"; Description: "开机时启动 {#MyAppName} Server"; GroupDescription: "附加任务："; Flags: unchecked

[Files]
// 确保 Source 指向您编译的32位 Bealink.exe
Source: "{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
// BonjourPSSetup.exe (更新为原始名称) 存放在临时目录，并在安装后删除
Source: "BonjourPSSetup.exe"; DestDir: "{tmp}"; Flags: deleteafterinstall
// AutoHotkey.exe - 注意：AutoHotkey也有32位和64位版本。为确保兼容性，您可能需要使用32位的AutoHotkey.exe
Source: "AutoHotkey.exe"; DestDir: "{app}"; Flags: ignoreversion
// icon.ico 将被复制到应用程序目录
Source: "icon.ico"; DestDir: "{app}"; Flags: ignoreversion
// AHK 脚本将被复制到应用程序目录
Source: "script\*"; DestDir: "{app}\script"; Flags: ignoreversion recursesubdirs createallsubdirs

[Icons]
// 在开始菜单中创建程序快捷方式
Name: "{group}\{#MyAppName} Server"; Filename: "{app}\{#MyAppExeName}"; WorkingDir: "{app}"
// 在开始菜单中创建卸载快捷方式
Name: "{group}\卸载 {#MyAppName} Server"; Filename: "{uninstallexe}"

[Run]
// 安装 Bonjour (如果 NeedsBonjour 函数返回 true)
Filename: "{tmp}\BonjourPSSetup.exe"; Parameters: ""; StatusMsg: "正在安装 Bonjour Print Services..."; Check: NeedsBonjour

// 安装后运行主程序 (可选，静默安装时跳过)
Filename: "{app}\{#MyAppExeName}"; Description: "运行 {#MyAppName} Server"; Flags: nowait postinstall skipifsilent

[Registry]
// 开机自启注册表项
Root: HKCU; Subkey: "Software\Microsoft\Windows\CurrentVersion\Run"; ValueName: "BealinkGoServer"; ValueType: string; ValueData: """{app}\{#MyAppExeName}"""; Tasks: autoStart; Flags: uninsdeletevalue

[UninstallDelete]
// 卸载时删除整个应用程序安装目录及其所有内容
Type: filesandordirs; Name: "{app}"
// 注意：用户配置目录将通过 [Code] 段的逻辑条件删除

[UninstallRegistry]
// 卸载时明确删除开机自启的注册表项
Root: HKCU; Subkey: "Software\Microsoft\Windows\CurrentVersion\Run"; ValueName: "BealinkGoServer"; Flags: deletevalue

[UninstallRun]
// 卸载前尝试结束正在运行的程序进程
Filename: "taskkill.exe"; Parameters: "/F /IM {#MyAppExeName}"; Flags: runhidden waituntilterminated

[Code]
var
  // 全局变量，用于存储用户是否选择删除配置数据
  g_ShouldRemoveUserConfig: Boolean;

// 在卸载程序初始化时调用
function InitializeUninstall(): Boolean;
begin
  // 默认不删除用户配置
  g_ShouldRemoveUserConfig := False;
  Log('卸载程序初始化。默认不删除用户配置。');
  Result := True; // 总是允许卸载继续
end;

// 当卸载步骤改变时调用 (此函数专用于卸载过程)
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  UserConfigDir: String;
  DirExistsStatus: Boolean;
  MsgBoxResult: Integer;
  DirExistsStatusString: String; // 用于日志记录的字符串
begin
  Log(Format('卸载步骤改变: %d', [CurUninstallStep]));

  // 在卸载程序即将开始实际删除文件前 (usUninstall) 询问用户
  if CurUninstallStep = usUninstall then
  begin
    UserConfigDir := ExpandConstant('{userappdata}\{#MyAppName}');
    DirExistsStatus := DirExists(UserConfigDir);

    // 准备用于日志的字符串
    if DirExistsStatus then
      DirExistsStatusString := '是'
    else
      DirExistsStatusString := '否';
    Log('用户配置目录: ' + UserConfigDir + ', 是否存在: ' + DirExistsStatusString);

    if DirExistsStatus then
    begin
      // 弹出消息框询问用户
      MsgBoxResult := MsgBox('您是否希望删除 {#MyAppName} 的个人配置数据？' + #13#10#13#10 +
                             '配置文件通常位于：' + #13#10 + UserConfigDir,
                             mbConfirmation, MB_YESNO);
      if MsgBoxResult = IDYES then
      begin
        g_ShouldRemoveUserConfig := True;
        Log('用户选择在卸载时删除用户配置数据。');
      end
      else
      begin
        g_ShouldRemoveUserConfig := False;
        Log('用户选择不删除用户配置数据。');
      end;
    end
    else
    begin
      Log('用户配置目录 ' + UserConfigDir + ' 不存在，无需询问删除。');
      g_ShouldRemoveUserConfig := False; // 目录不存在，无需删除
    end;
  end;
end;

// 在卸载过程完全结束后调用
procedure DeinitializeUninstall();
var
  UserConfigPath: String;
begin
  Log('卸载过程结束 (DeinitializeUninstall)。');
  if g_ShouldRemoveUserConfig then
  begin
    UserConfigPath := ExpandConstant('{userappdata}\{#MyAppName}');
    Log('根据用户选择，尝试删除用户配置目录: ' + UserConfigPath);
    if DirExists(UserConfigPath) then
    begin
      if DelTree(UserConfigPath, True, True, True) then
        Log('用户配置目录已成功删除: ' + UserConfigPath)
      else
      begin
        Log('删除用户配置目录失败: ' + UserConfigPath);
      end;
    end
    else
      Log('用户配置目录未找到（可能在卸载过程中已被其他方式移除），无需删除: ' + UserConfigPath);
  end
  else
  begin
    Log('用户未选择删除用户配置数据，或目录不存在。');
  end;
end;

// InitializeSetup 在安装开始时运行
function InitializeSetup(): Boolean;
var
  UninstPath: String;
  ExistingVersion: String;
  VersionInfoString: String;
  MsgText: String;
begin
  // 检查注册表中是否有基于 AppId 的已安装记录
  // 对于32位安装程序，在64位系统上默认会查询 HKLM\Software\Wow6432Node
  // 如果旧版本是以不同模式（如纯64位）安装的，这里的检测可能需要调整
  if RegQueryStringValue(HKEY_LOCAL_MACHINE, 'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}_is1', 'UninstallString', UninstPath) or
     RegQueryStringValue(HKEY_CURRENT_USER, 'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}_is1', 'UninstallString', UninstPath) then
  begin
    ExistingVersion := '';
    if not RegQueryStringValue(HKEY_LOCAL_MACHINE, 'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}_is1', 'DisplayVersion', ExistingVersion) then
    begin
      RegQueryStringValue(HKEY_CURRENT_USER, 'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}_is1', 'DisplayVersion', ExistingVersion);
    end;

    if ExistingVersion <> '' then
      VersionInfoString := '(版本: ' + ExistingVersion + ') '
    else
      VersionInfoString := '';

    MsgText := '检测到 {#MyAppName} 已安装 ' + VersionInfoString + '。是否要继续安装并覆盖现有版本？';

    if MsgBox(MsgText, mbConfirmation, MB_YESNO) = IDNO then
    begin
      Result := False;
      Log('用户选择不覆盖已安装的 {#MyAppName}.');
    end
    else
    begin
      Result := True;
      Log('用户选择覆盖已安装的 {#MyAppName}.');
    end;
  end
  else
  begin
    Result := True;
    Log('未检测到 {#MyAppName} 的已安装版本，正常继续安装。');
  end;
end;

// NeedsBonjour 检测 Bonjour 是否已安装 (更稳健的方法)
function NeedsBonjour: Boolean;
var
  PathToDnssd_dll: String;
begin
  // 您的应用程序 BeaLink.exe 是32位的。
  // 它将需要32位的 dnssd.dll。
  // - 在32位Windows上, 32位 dnssd.dll 位于 C:\Windows\System32
  // - 在64位Windows上, 32位 dnssd.dll 位于 C:\Windows\SysWOW64
  // Inno Setup 的 {sys} 常量在32位安装程序进程中会正确解析到这些位置。
  PathToDnssd_dll := ExpandConstant('{sys}\dnssd.dll');

  Log('检查 Bonjour DLL (供32位应用程序使用): ' + PathToDnssd_dll);
  if FileExists(PathToDnssd_dll) then
  begin
    Log('找到 dnssd.dll 于: ' + PathToDnssd_dll + '. 假设 Bonjour 已安装。');
    Result := False; // Bonjour 已存在，不需要安装
  end
  else
  begin
    Log('未找到 dnssd.dll 于: ' + PathToDnssd_dll + '. 假设需要安装 Bonjour。');
    Result := True; // Bonjour 不存在，需要安装
  end;
end;

// CurStepChanged 在安装步骤改变时被调用 (此函数专用于安装过程)
procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssInstall then
  begin
    Log('安装步骤开始 (ssInstall)。');
  end
  else if CurStep = ssPostInstall then
  begin
    Log('安装后步骤 (ssPostInstall)。');
  end;
end;
