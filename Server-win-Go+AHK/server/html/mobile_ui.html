<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Bealink">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#f2f2f7" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <title>Bealink æ§åˆ¶å°</title>
    <!-- Favicon and Apple Touch Icon for iOS -->
    <!-- Static icons in HTML head for iOS to detect before JavaScript loads -->
    <link rel="icon" type="image/x-icon" sizes="180x180" href="/icon.ico?theme=light">
    <link rel="icon" type="image/x-icon" href="/icon.ico?theme=light">
    <link rel="apple-touch-icon" sizes="180x180" href="/icon.ico?theme=light">
    <link rel="apple-touch-icon" href="/icon.ico?theme=light">
    <!-- Dynamic icon update script -->
    <script>
        (function() {
            function updateIcons() {
                const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = isDark ? 'dark' : 'light';
                const iconUrl = '/icon.ico?theme=' + theme;
                const faviconUrl = '/favicon.ico?theme=' + theme;
                
                // Update standard favicon
                let link = document.querySelector("link[rel*='icon']:not([rel='apple-touch-icon'])");
                if (link) {
                    link.href = iconUrl;
                }
                
                // Update apple-touch-icon
                let appleLink = document.querySelector("link[rel='apple-touch-icon']");
                if (appleLink) {
                    appleLink.href = iconUrl;
                } else {
                    appleLink = document.createElement('link');
                    appleLink.rel = 'apple-touch-icon';
                    appleLink.href = iconUrl;
                    document.head.appendChild(appleLink);
                }
            }
            
            // Initial update
            updateIcons();
            
            // Listen for theme changes
            const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            if (mediaQuery.addEventListener) {
                mediaQuery.addEventListener('change', updateIcons);
            } else if (mediaQuery.addListener) {
                mediaQuery.addListener(updateIcons);
            }
        })();
    </script>
    <style>
        :root {
            --bg: #f2f2f7; --card: #fff; --text: #000; --sub: #8e8e93;
            --accent: #007aff; --track: #e5e5ea; --danger: #ff3b30;
        }
        @media (prefers-color-scheme: dark) {
            :root { --bg: #000; --card: #1c1c1e; --text: #fff; --sub: #98989d; --track: #2c2c2e; }
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body {
            font-family: -apple-system, sans-serif; background: var(--bg); color: var(--text);
            margin: 0; padding: 28px 20px 20px 20px; display: flex; flex-direction: column; gap: 24px;
            height: 100vh; overflow: hidden; touch-action: none; overscroll-behavior: none;
        }

        /* é¡¶éƒ¨çŠ¶æ€ */
        .header { display: flex; justify-content: space-between; align-items: center; padding: 0 5px; }
        .title { font-size: 24px; font-weight: 800; }
        .badge { font-size: 12px; color: var(--accent); background: rgba(0,122,255,0.1); padding: 4px 10px; border-radius: 12px; font-weight: 600; }
        .badge.online { color: #34c759; background: rgba(52,199,89,0.1); }
        .badge.offline { color: #ff3b30; background: rgba(255,59,48,0.1); }

        /* å¡ç‰‡å®¹å™¨ */
        .card { background: var(--card); border-radius: 20px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }

        /* åª’ä½“ä¿¡æ¯ */
        .media-info { text-align: center; margin-bottom: 24px; }
        .song { font-size: 18px; font-weight: 700; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .artist { font-size: 14px; color: var(--sub); }

        /* æ’­æ”¾æ§åˆ¶ */
        .controls { display: flex; justify-content: center; align-items: center; gap: 40px; margin-bottom: 24px; }
        .btn { background: none; border: none; color: var(--text); cursor: pointer; transition: transform 0.1s; display: flex; align-items: center; justify-content: center; }
        .btn:active { transform: scale(0.85); opacity: 0.7; }
        .btn-side { width: 40px; height: 40px; }
        .btn-side svg { width: 28px; height: 28px; fill: currentColor; }
        .btn-play { width: 70px; height: 70px; background: var(--text); color: var(--bg); border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }
        .btn-play svg { width: 32px; height: 32px; fill: currentColor; }

        /* iOS é£æ ¼éŸ³é‡æ¡ */
        .volume-container { 
            display: flex; align-items: center; gap: 12px; 
            background: var(--track); padding: 6px 16px 6px 6px; border-radius: 16px; 
        }
        .vol-btn { 
            width: 36px; height: 36px; border-radius: 12px; background: var(--card); 
            display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.05); 
        }
        .vol-btn svg { width: 18px; height: 18px; fill: var(--sub); }
        
        .slider-wrapper { flex: 1; position: relative; height: 36px; display: flex; align-items: center; }
        input[type=range] {
            -webkit-appearance: none; width: 100%; height: 6px; background-color: var(--track); border-radius: 999px;
            position: relative; z-index: 2; margin: 0; padding: 0; overflow: visible;
        }
        input[type=range]:focus { outline: none; }
        /* ä½¿ç”¨é€æ˜è½¨é“ï¼Œè¿›åº¦ç”±å…ƒç´ èƒŒæ™¯ (linear-gradient) ç»˜åˆ¶ */
        input[type=range]::-webkit-slider-runnable-track {
            height: 6px; background: transparent; border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 20px; width: 20px; border-radius: 50%; background: var(--card);
            box-shadow: 0 2px 6px rgba(0,0,0,0.18); cursor: pointer; -webkit-appearance: none; margin-top: -7px;
        }
        input[type=range]::-moz-range-track { height: 6px; background: transparent; border-radius: 3px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: var(--card); box-shadow: 0 2px 6px rgba(0,0,0,0.18); }

        /* æ–‡æœ¬è¾“å…¥ (IM é£æ ¼) */
        .input-area { display: flex; gap: 10px; align-items: center; }
        textarea {
            flex: 1; min-height: 64px; max-height: 30vh; border: none; background: var(--track); border-radius: 18px;
            padding: 12px 16px; font-size: 16px; color: var(--text); resize: none; font-family: inherit; overflow: auto;
            line-height: 1.4;
        }
        textarea:focus { outline: none; background: rgba(142,142,147, 0.15); }
        .send-btn {
            width: 50px; height: 50px; border-radius: 50%; background: var(--accent);
            color: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 10px rgba(0,122,255,0.3);
        }
        .send-btn svg { width: 22px; height: 22px; fill: none; stroke: currentColor; stroke-width: 2.5; }

        /* åº•éƒ¨åŠŸèƒ½ç½‘æ ¼ */
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
        .tile {
            background: var(--card); border-radius: 16px; height: 90px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 10px; font-size: 13px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            position: relative; overflow: hidden;
        }
        .tile:active { transform: scale(0.96); background: var(--track); }
        .tile-icon { font-size: 28px; }
        .danger { color: var(--danger); }
        
        /* ä¸Šä¼ åŒº */
        .upload { 
            position: sticky; bottom: 20px; z-index: 6; overflow: hidden;
            border: 2px dashed var(--sub); border-radius: 16px; padding: 12px;
            text-align: center; font-size: 14px; color: var(--sub); opacity: 0.9; background: rgba(255,255,255,0.02);
        }
        .upload input { position: absolute; top:0; left:0; width:100%; height:100%; opacity:0; }
        .tile .progress {
            position: absolute; left: 0; top: 0; bottom: 0; width: 0%; z-index: 0;
            background: rgba(0,122,255,0.12); transition: width linear;
        }
        .tile > * { z-index: 1; }
    </style>
</head>
<body>

    <div class="header">
        <div class="title">Bealink</div>
        <div style="display: flex; gap: 12px; align-items: center;">
            <div class="badge" id="deviceStatus">è®¾å¤‡åœ¨çº¿</div>
            <a href="/setting" style="font-size: 12px; color: var(--accent); text-decoration: none; padding: 4px 10px; border-radius: 12px; background: rgba(0,122,255,0.1); font-weight: 600;">è®¾ç½®</a>
        </div>
    </div>

    <!-- åª’ä½“å¡ç‰‡ -->
    <div class="card">
        <div class="media-info">
            <div class="song" id="mTitle">åª’ä½“æ§åˆ¶</div>
            <div class="artist" id="mArtist"></div>
        </div>

        <div class="controls">
            <button class="btn btn-side" onclick="api('/media/prev')">
                <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
            </button>
            <button class="btn btn-play" id="playBtn" onclick="api('/media/play')">
                <!-- åŒæ—¶å±•ç¤ºæ’­æ”¾ä¸æš‚åœå›¾æ ‡ï¼ˆå¤šåŠŸèƒ½æŒ‰é’®ï¼‰ï¼Œå‰ç«¯ä¸å†æ ¹æ®çŠ¶æ€åˆ‡æ¢ -->
                <svg viewBox="0 0 24 24" style="margin-right:6px"><path d="M8 5v14l11-7z"/></svg>
                <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
            <button class="btn btn-side" onclick="api('/media/next')">
                <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
            </button>
        </div>

        <!-- éŸ³é‡æ¡ (æ‹–æ‹½ä¼˜åŒ–) -->
        <div class="volume-container">
            <button class="vol-btn" onclick="setVolumeZero()">
                <svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-8-7.27-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
            </button>
            <div class="slider-wrapper">
                <input type="range" id="volSlider" min="0" max="100" value="0" oninput="onVolInput(this)" onchange="onVolChange(this)">
            </div>
            <div style="min-width: 45px; text-align: center; font-weight: 600; font-size: 14px; color: var(--text);" id="volPercent">0%</div>
            <button class="vol-btn" onclick="stepVol(5)">
                <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
            </button>
        </div>
    </div>

    <!-- æ–‡æœ¬è¾“å…¥ -->
    <div class="card" style="padding: 16px;">
        <div class="input-area">
            <textarea id="txt" placeholder="å‘é€æ–‡å­—..."></textarea>
            <button class="send-btn" onclick="sendText()">
                <svg viewBox="0 0 24 24"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
        </div>
    </div>

    <!-- åŠŸèƒ½åŒº -->
    <div class="grid">
        <div class="tile" onclick="api('/monitor')">
            <span class="tile-icon">ğŸ–¥ï¸</span>
            <span>æ¯å±</span>
        </div>
        <div class="tile" id="sleepTile" onclick="toggleCountdown('sleep', this)">
            <span class="tile-icon">ğŸŒ™</span>
            <span>ç¡çœ </span>
        </div>
        <div class="tile danger" id="shutdownTile" onclick="toggleCountdown('shutdown', this)">
            <span class="tile-icon">â­•</span>
            <span>å…³æœº</span>
        </div>
    </div>

    <div class="upload">
        ğŸ“¤ ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡åˆ°å‰ªè´´æ¿
        <input type="file" accept="image/*" onchange="uploadImage(this)">
    </div>

    <script>
        // çŠ¶æ€é”ï¼šç”¨æˆ·æ‹–æ‹½æ—¶æš‚åœè½®è¯¢æ›´æ–°
        let isDragging = false;
        let lastVol = -1;
        let volumePollInterval = null;
        let deviceOnline = true; // è®¾å¤‡åœ¨çº¿çŠ¶æ€
        let consecutiveFailures = 0; // è¿ç»­å¤±è´¥æ¬¡æ•°
        const MAX_FAILURES = 2; // è¿ç»­å¤±è´¥2æ¬¡åæ ‡è®°ä¸ºç¦»çº¿
        
        // WebSocket è¿æ¥
        let wsSocket = null;
        let wsReconnectTimer = null;
        let wsHeartbeatTimer = null;
        const WS_RECONNECT_DELAY = 3000; // 3ç§’åé‡è¿
        const WS_HEARTBEAT_INTERVAL = 2000; // 10ç§’å‘é€ä¸€æ¬¡å¿ƒè·³ï¼ˆpingï¼‰
        let lastPongTime = Date.now();

        async function api(url) {
            if(navigator.vibrate) navigator.vibrate(10);
            try { await fetch(url); syncStatus(); } catch(e){}
        }

        // éŸ³é‡é€»è¾‘
        let debounceTimer;
        
        // æ‹–æ‹½ä¸­ï¼šåªå‘é€è¯·æ±‚ï¼Œä¸æ›´æ–°UI
        function onVolInput(el) {
            isDragging = true;
            if(debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                fetch('/volume/set?val=' + el.value);
            }, 100); // 100ms èŠ‚æµ
            // è§†è§‰ä¸Šå®æ—¶æ›´æ–°è¿›åº¦
            updateRangeBackground(el);
        }

        // æ‹–æ‹½ç»“æŸï¼šç«‹å³å‘é€ï¼Œå»¶è¿Ÿ 500ms æ¢å¤è½®è¯¢ï¼ˆç­‰å¾…æœåŠ¡å™¨ç”Ÿæ•ˆï¼‰
        function onVolChange(el) {
            fetch('/volume/set?val=' + el.value);
            setTimeout(() => { isDragging = false; }, 500);
            updateRangeBackground(el);
        }

        // æ­¥è¿›éŸ³é‡
        function stepVol(delta) {
            const el = document.getElementById('volSlider');
            let v = parseInt(el.value) + delta;
            if (v>100) v=100; if (v<0) v=0;
            el.value = v;
            onVolChange(el);
        }

        // æ–‡æœ¬å‘é€
        async function sendText() {
            const el = document.getElementById('txt');
            if(!el.value) return;
            await fetch('/text', {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: 'text=' + encodeURIComponent(el.value)
            });
            el.value = '';
        }

        // å›¾ç‰‡ä¸Šä¼ 
        async function uploadImage(el) {
            const file = el.files[0];
            if(!file) return;
            const data = new FormData();
            data.append('image', file);
            await fetch('/upload/image', { method: 'POST', body: data });
            el.value = '';
            alert('å›¾ç‰‡å·²å‘é€');
        }

        // æ›´æ–°è®¾å¤‡åœ¨çº¿çŠ¶æ€æ˜¾ç¤º
        function updateDeviceStatus(isOnline) {
            const statusEl = document.getElementById('deviceStatus');
            if (!statusEl) return;
            
            // åªæœ‰å½“çŠ¶æ€çœŸæ­£æ”¹å˜æ—¶æ‰æ›´æ–°
            if (deviceOnline === isOnline) return;
            
            deviceOnline = isOnline;
            if (isOnline) {
                statusEl.textContent = 'è®¾å¤‡åœ¨çº¿';
                statusEl.className = 'badge online';
            } else {
                statusEl.textContent = 'è®¾å¤‡ä¸åœ¨çº¿';
                statusEl.className = 'badge offline';
            }
        }
        
        // è¿æ¥ WebSocketï¼ˆç”¨äºæ—¥å¿—å’Œåœ¨çº¿çŠ¶æ€æ£€æµ‹ï¼‰
        function connectWebSocket() {
            // æ„å»º WebSocket URL
            const wsScheme = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsURL = `${wsScheme}//${window.location.host}/ws/logs`;
            
            try {
                wsSocket = new WebSocket(wsURL);
                
                wsSocket.onopen = function(event) {
                    console.log('WebSocket è¿æ¥å·²æ‰“å¼€');
                    // WebSocket è¿æ¥æˆåŠŸï¼Œè®¾å¤‡åœ¨çº¿
                    consecutiveFailures = 0;
                    lastPongTime = Date.now();
                    updateDeviceStatus(true);
                    // æ¸…é™¤é‡è¿å®šæ—¶å™¨
                    if (wsReconnectTimer) {
                        clearTimeout(wsReconnectTimer);
                        wsReconnectTimer = null;
                    }
                    // å¯åŠ¨å¿ƒè·³æ£€æµ‹
                    startHeartbeat();
                };
                
                wsSocket.onmessage = function(event) {
                    // æ”¶åˆ°æ¶ˆæ¯è¯´æ˜è¿æ¥æ­£å¸¸ï¼Œè®¾å¤‡åœ¨çº¿
                    lastPongTime = Date.now();
                    consecutiveFailures = 0;
                    if (!deviceOnline) {
                        updateDeviceStatus(true);
                    }
                    // è¿™é‡Œå¯ä»¥å¤„ç†æ—¥å¿—æ¶ˆæ¯ï¼Œä½†ä¸»ç•Œé¢ä¸éœ€è¦æ˜¾ç¤ºæ—¥å¿—
                };
                
                wsSocket.onclose = function(event) {
                    console.log('WebSocket è¿æ¥å·²å…³é—­:', event);
                    wsSocket = null;
                    stopHeartbeat();
                    // WebSocket æ–­å¼€ï¼Œç«‹å³æ ‡è®°ä¸ºç¦»çº¿
                    updateDeviceStatus(false);
                    // å°è¯•é‡è¿
                    if (wsReconnectTimer) {
                        clearTimeout(wsReconnectTimer);
                    }
                    wsReconnectTimer = setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
                };
                
                wsSocket.onerror = function(error) {
                    console.error('WebSocket é”™è¯¯:', error);
                    stopHeartbeat();
                    // WebSocket é”™è¯¯ï¼Œæ ‡è®°ä¸ºç¦»çº¿
                    updateDeviceStatus(false);
                };
            } catch (e) {
                console.error('åˆ›å»º WebSocket è¿æ¥å¤±è´¥:', e);
                stopHeartbeat();
                updateDeviceStatus(false);
                // å°è¯•é‡è¿
                if (wsReconnectTimer) {
                    clearTimeout(wsReconnectTimer);
                }
                wsReconnectTimer = setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
            }
        }
        
        // å¯åŠ¨å¿ƒè·³æ£€æµ‹ï¼ˆç”¨äºå¿«é€Ÿæ£€æµ‹è¿æ¥æ–­å¼€ï¼Œå¦‚ç”µè„‘ç¡çœ ï¼‰
        function startHeartbeat() {
            stopHeartbeat(); // å…ˆæ¸…é™¤æ—§çš„å®šæ—¶å™¨
            wsHeartbeatTimer = setInterval(() => {
                if (wsSocket && wsSocket.readyState === WebSocket.OPEN) {
                    // æ£€æŸ¥æ˜¯å¦é•¿æ—¶é—´æ²¡æœ‰æ”¶åˆ°æ¶ˆæ¯ï¼ˆå¯èƒ½è¿æ¥å·²æ–­å¼€ä½†æœªè§¦å‘ oncloseï¼Œå¦‚ç”µè„‘ç¡çœ ï¼‰
                    const timeSinceLastPong = Date.now() - lastPongTime;
                    if (timeSinceLastPong > WS_HEARTBEAT_INTERVAL * 3) {
                        // è¶…è¿‡30ç§’æ²¡æœ‰æ”¶åˆ°ä»»ä½•æ¶ˆæ¯ï¼ˆåŒ…æ‹¬æ—¥å¿—æ¨é€ï¼‰ï¼Œè®¤ä¸ºè¿æ¥å·²æ–­å¼€
                        console.log('WebSocket å¿ƒè·³è¶…æ—¶ï¼Œè¿æ¥å¯èƒ½å·²æ–­å¼€ï¼ˆå¯èƒ½ç”µè„‘å·²ç¡çœ ï¼‰');
                        updateDeviceStatus(false);
                        if (wsSocket) {
                            try {
                                wsSocket.close();
                            } catch (e) {
                                // å¿½ç•¥å…³é—­é”™è¯¯
                            }
                        }
                        // è§¦å‘é‡è¿
                        if (wsReconnectTimer) {
                            clearTimeout(wsReconnectTimer);
                        }
                        wsReconnectTimer = setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
                        return;
                    }
                } else if (wsSocket && wsSocket.readyState !== WebSocket.CONNECTING) {
                    // WebSocket çŠ¶æ€å¼‚å¸¸ï¼Œæ ‡è®°ä¸ºç¦»çº¿
                    updateDeviceStatus(false);
                }
            }, WS_HEARTBEAT_INTERVAL);
        }
        
        // åœæ­¢å¿ƒè·³æ£€æµ‹
        function stopHeartbeat() {
            if (wsHeartbeatTimer) {
                clearInterval(wsHeartbeatTimer);
                wsHeartbeatTimer = null;
            }
        }
        
        // å…³é—­ WebSocket è¿æ¥
        function closeWebSocket() {
            stopHeartbeat();
            if (wsReconnectTimer) {
                clearTimeout(wsReconnectTimer);
                wsReconnectTimer = null;
            }
            if (wsSocket) {
                wsSocket.close();
                wsSocket = null;
            }
        }

        // è·å–éŸ³é‡ä¿¡æ¯å¹¶æ›´æ–°UIï¼ˆä½œä¸º WebSocket çš„å¤‡ç”¨æ£€æµ‹æ–¹å¼ï¼‰
        function fetchVolume() {
            if (isDragging) return;
            // å¦‚æœ WebSocket å·²è¿æ¥ï¼Œä¸»è¦ä¾èµ– WebSocket çŠ¶æ€ï¼ŒHTTP è½®è¯¢ä½œä¸ºå¤‡ç”¨
            if (wsSocket && wsSocket.readyState === WebSocket.OPEN) {
                // WebSocket å·²è¿æ¥ï¼Œåªæ›´æ–°éŸ³é‡ï¼Œä¸ç”¨äºåœ¨çº¿çŠ¶æ€æ£€æµ‹
                fetch('/volume/info', { 
                    method: 'GET',
                    signal: AbortSignal.timeout(2000) // 2ç§’è¶…æ—¶
                })
                    .then(r => {
                        if (!r.ok) {
                            throw new Error(`HTTP ${r.status}`);
                        }
                        return r.json();
                    })
                    .then(vInfo => {
                        const slider = document.getElementById('volSlider');
                        const volPercent = document.getElementById('volPercent');
                        if (slider && vInfo.volume !== undefined) {
                            const vol = Math.round(vInfo.volume);
                            slider.value = vol;
                            updateRangeBackground(slider);
                            if (volPercent) {
                                volPercent.textContent = vol + '%';
                            }
                        }
                    })
                    .catch(e => {
                        // HTTP å¤±è´¥ä¸å½±å“åœ¨çº¿çŠ¶æ€ï¼ˆå› ä¸º WebSocket å·²è¿æ¥ï¼‰
                        console.log('fetchVolume err (WebSocketå·²è¿æ¥ï¼Œå¿½ç•¥)', e);
                    });
            } else {
                // WebSocket æœªè¿æ¥ï¼Œä½¿ç”¨ HTTP è½®è¯¢ä½œä¸ºåœ¨çº¿çŠ¶æ€æ£€æµ‹
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000); // 2ç§’è¶…æ—¶
                    
                    fetch('/volume/info', { 
                        method: 'GET',
                        signal: controller.signal
                    })
                        .then(r => {
                            clearTimeout(timeoutId);
                            if (!r.ok) {
                                throw new Error(`HTTP ${r.status}`);
                            }
                            return r.json();
                        })
                        .then(vInfo => {
                            // æˆåŠŸè·å–åˆ°å“åº”ï¼Œè®¾å¤‡åœ¨çº¿
                            consecutiveFailures = 0;
                            if (!deviceOnline) {
                                updateDeviceStatus(true);
                            }
                            
                            const slider = document.getElementById('volSlider');
                            const volPercent = document.getElementById('volPercent');
                            if (slider && vInfo.volume !== undefined) {
                                const vol = Math.round(vInfo.volume);
                                slider.value = vol;
                                updateRangeBackground(slider);
                                if (volPercent) {
                                    volPercent.textContent = vol + '%';
                                }
                            }
                        })
                        .catch(e => {
                            clearTimeout(timeoutId);
                            console.log('fetchVolume err', e);
                            consecutiveFailures++;
                            // è¿ç»­å¤±è´¥è¾¾åˆ°é˜ˆå€¼ï¼Œæ ‡è®°ä¸ºç¦»çº¿
                            if (consecutiveFailures >= MAX_FAILURES) {
                                updateDeviceStatus(false);
                            }
                        });
                } catch (e) {
                    console.log('fetchVolume err', e);
                    consecutiveFailures++;
                    if (consecutiveFailures >= MAX_FAILURES) {
                        updateDeviceStatus(false);
                    }
                }
            }
        }

        // å¯åŠ¨è®¾å¤‡è¿æ¥å’ŒéŸ³é‡è½®è¯¢ï¼ˆæ¯500msä¸€æ¬¡ï¼‰
        function startVolumePolling() {
            if (volumePollInterval) return; // å·²ç»å¯åŠ¨
            // å…ˆè¿æ¥ WebSocketï¼ˆä¸»è¦æ£€æµ‹æ–¹å¼ï¼‰
            connectWebSocket();
            // ç„¶åå¯åŠ¨ HTTP è½®è¯¢ï¼ˆå¤‡ç”¨æ£€æµ‹æ–¹å¼å’ŒéŸ³é‡æ›´æ–°ï¼‰
            fetchVolume(); // ç«‹å³è·å–ä¸€æ¬¡
            volumePollInterval = setInterval(fetchVolume, 500);
        }

        // åœæ­¢éŸ³é‡è½®è¯¢å’Œ WebSocket
        function stopVolumePolling() {
            if (volumePollInterval) {
                clearInterval(volumePollInterval);
                volumePollInterval = null;
            }
            closeWebSocket();
        }

        // å¯åŠ¨
        // è‡ªåŠ¨è°ƒæ•´ textarea é«˜åº¦ï¼Œé¿å…æ¨é€ä¸Šä¼ åŒºå‡ºå±
        function adjustTextarea(el) {
            if(!el) return;
            // æœ€å¤§é«˜åº¦ä¸ºè§†çª—é«˜åº¦çš„æ¯”ä¾‹ï¼Œç¡®ä¿åº•éƒ¨ä¸Šä¼ åŒºå§‹ç»ˆå¯è§
            const maxPx = Math.round(window.innerHeight * 0.30);
            el.style.height = 'auto';
            const newH = Math.min(el.scrollHeight, maxPx);
            el.style.height = newH + 'px';
        }

        const txtEl = document.getElementById('txt');
        if (txtEl) {
            txtEl.addEventListener('input', function(){ adjustTextarea(this); });
            // åœ¨å‘é€åä¹Ÿæ”¶ç¼©å›æœ€å°é«˜åº¦
            const originalSend = sendText;
            sendText = async function(){ await originalSend(); adjustTextarea(txtEl); };
            // åˆå§‹è°ƒæ•´
            window.addEventListener('load', () => adjustTextarea(txtEl));
            window.addEventListener('resize', () => adjustTextarea(txtEl));
        }

        // ä½¿ç”¨èƒŒæ™¯ linear-gradient ç»˜åˆ¶ä¸»é¢˜è‰²è¿›åº¦
        function updateRangeBackground(el) {
            if(!el) return;
            const min = parseFloat(el.min) || 0;
            const max = parseFloat(el.max) || 100;
            const val = parseFloat(el.value) || 0;
            const pct = Math.round((val - min) / (max - min) * 100);
            // ä½¿ç”¨ single background ä¿è¯å…¼å®¹æ€§ï¼šå‰æ™¯ä¸ºä¸»é¢˜è‰²ï¼Œåæ™¯ä¸ºç°è‰²è½¨é“
            el.style.background = `linear-gradient(90deg, var(--accent) ${pct}%, var(--track) ${pct}%)`;
            // åŒæ­¥æ›´æ–°ç™¾åˆ†æ¯”æ˜¾ç¤º
            const volPercent = document.getElementById('volPercent');
            if (volPercent) {
                volPercent.textContent = Math.round(val) + '%';
            }
        }

        // åˆå§‹åŒ–éŸ³é‡æ»‘å—èƒŒæ™¯
        const volEl = document.getElementById('volSlider');
        if (volEl) {
            updateRangeBackground(volEl);
            volEl.addEventListener('input', function(){ updateRangeBackground(this); });
            window.addEventListener('load', () => { 
                updateRangeBackground(volEl); 
                startVolumePolling(); // å¯åŠ¨ WebSocket å’ŒéŸ³é‡è½®è¯¢
            });
            window.addEventListener('resize', () => updateRangeBackground(volEl));
            // é¡µé¢å¸è½½æ—¶åœæ­¢è½®è¯¢å’Œ WebSocket
            window.addEventListener('beforeunload', stopVolumePolling);
            // é¡µé¢éšè—æ—¶ä¹Ÿåœæ­¢ï¼ˆèŠ‚çœèµ„æºï¼‰
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // é¡µé¢éšè—æ—¶ä¸æ–­å¼€ï¼Œåªæ˜¯æš‚åœéƒ¨åˆ†æ›´æ–°
                } else {
                    // é¡µé¢æ˜¾ç¤ºæ—¶ç¡®ä¿è¿æ¥
                    if (!wsSocket || wsSocket.readyState !== WebSocket.OPEN) {
                        connectWebSocket();
                    }
                }
            });
        }

        // å‰ç«¯é™éŸ³ï¼šæŠŠæ»‘å—è®¾ä¸º0å¹¶å‘é€è®¾ç½®è¯·æ±‚
        function setVolumeZero() {
            const el = document.getElementById('volSlider');
            if (!el) return;
            el.value = 0;
            updateRangeBackground(el);
            // è§¦å‘åç«¯è®¾ç½®
            fetch('/volume/set?val=0').catch(()=>{});
            // çŸ­æš‚æš‚åœè½®è¯¢ï¼Œç­‰å¾…æœåŠ¡å™¨ç”Ÿæ•ˆ
            isDragging = true;
            setTimeout(() => { isDragging = false; }, 600);
        }

        // toggleCountdown è°ƒç”¨ /sleep æˆ– /shutdownï¼Œæ”¯æŒ start/cancel
        async function toggleCountdown(kind, el) {
            const path = kind === 'sleep' ? '/sleep' : '/shutdown';
            try {
                const res = await fetch(path);
                const txt = await res.text();
                let data = {};
                try { data = JSON.parse(txt); } catch(e) { data = { status: 'ok' }; }

                const duration = data.duration || 5;
                const status = data.status || 'ok';
                const tile = el;
                let prog = tile.querySelector('.progress');
                if (!prog) {
                    prog = document.createElement('div'); prog.className = 'progress'; tile.appendChild(prog);
                }

                if (status === 'started') {
                            // ä½¿ç”¨åŸºäºç™¾åˆ†æ¯”çš„å®šæ—¶å™¨æ¥æ˜¾ç¤ºå€’è®¡æ—¶è¿›åº¦ï¼ˆé¿å… CSS åŠ¨ç”»å›å¼¹ï¼‰
                            clearInterval(tile._countdownInterval || 0);
                            tile.dataset.counting = '1';
                            prog.style.transition = 'none';
                            prog.style.width = '0%';
                            const startTs = Date.now();
                            const totalMs = duration * 1000;
                            tile._countdownInterval = setInterval(() => {
                                const elapsed = Date.now() - startTs;
                                let pct = Math.round(Math.min(1, elapsed / totalMs) * 100);
                                prog.style.width = pct + '%';
                                if (elapsed >= totalMs) {
                                    clearInterval(tile._countdownInterval);
                                    tile._countdownInterval = 0;
                                    tile.dataset.counting = '';
                                    // ä¿æŒæ»¡æ ¼çŸ­æš‚åå½’é›¶
                                    setTimeout(() => { prog.style.width = '0%'; }, 600);
                                }
                            }, 100);
                } else if (status === 'cancelled') {
                            // å–æ¶ˆå€’è®¡æ—¶ï¼šæ¸…é™¤å®šæ—¶å™¨å¹¶å›åˆ° 0
                            if (tile._countdownInterval) { clearInterval(tile._countdownInterval); tile._countdownInterval = 0; }
                            prog.style.transition = 'width 0.2s linear';
                            prog.style.width = '0%';
                            tile.dataset.counting = '';
                } else if (status === 'executed') {
                            // ç›´æ¥è®¾ç½®ä¸ºæ»¡æ ¼å¹¶åœæ­¢å®šæ—¶å™¨
                            if (tile._countdownInterval) { clearInterval(tile._countdownInterval); tile._countdownInterval = 0; }
                            prog.style.width = '100%';
                            tile.dataset.counting = '';
                            setTimeout(()=>{ prog.style.width='0%'; }, 800);
                }
            } catch (e) {
                console.log('toggle error', e);
            }
        }

        // ä¸è¿›è¡ŒæŒç»­è½®è¯¢ï¼Œé¡µé¢åŠ è½½æ—¶ä¼šè¯»å–ä¸€æ¬¡éŸ³é‡
    </script>
</body>
</html>