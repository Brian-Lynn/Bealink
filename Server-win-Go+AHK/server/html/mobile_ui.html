<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Bealink">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#f2f2f7" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <title>Bealink æ§åˆ¶å°</title>
    <!-- Favicon and Apple Touch Icon for iOS -->
    <!-- Static icons in HTML head for iOS to detect before JavaScript loads -->
    <link rel="icon" type="image/x-icon" sizes="180x180" href="/icon.ico?theme=light">
    <link rel="icon" type="image/x-icon" href="/icon.ico?theme=light">
    <link rel="apple-touch-icon" sizes="180x180" href="/icon.ico?theme=light">
    <link rel="apple-touch-icon" href="/icon.ico?theme=light">
    <!-- Dynamic icon update script -->
    <script>
        (function() {
            function updateIcons() {
                const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = isDark ? 'dark' : 'light';
                const iconUrl = '/icon.ico?theme=' + theme;
                const faviconUrl = '/favicon.ico?theme=' + theme;
                
                // Update standard favicon
                let link = document.querySelector("link[rel*='icon']:not([rel='apple-touch-icon'])");
                if (link) {
                    link.href = iconUrl;
                }
                
                // Update apple-touch-icon
                let appleLink = document.querySelector("link[rel='apple-touch-icon']");
                if (appleLink) {
                    appleLink.href = iconUrl;
                } else {
                    appleLink = document.createElement('link');
                    appleLink.rel = 'apple-touch-icon';
                    appleLink.href = iconUrl;
                    document.head.appendChild(appleLink);
                }
            }
            
            // Initial update
            updateIcons();
            
            // Listen for theme changes
            const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            if (mediaQuery.addEventListener) {
                mediaQuery.addEventListener('change', updateIcons);
            } else if (mediaQuery.addListener) {
                mediaQuery.addListener(updateIcons);
            }
        })();
    </script>
    <style>
        :root {
            --bg: #f2f2f7; --card: #fff; --text: #000; --sub: #8e8e93;
            --accent: #007aff; --track: #e5e5ea; --danger: #ff3b30; --input-bg: #eff1f5;
        }
        @media (prefers-color-scheme: dark) {
            :root { --bg: #000; --card: #1c1c1e; --text: #fff; --sub: #98989d; --track: #2c2c2e; --input-bg: #2c2c2e; }
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body {
            font-family: -apple-system, sans-serif; background: var(--bg); color: var(--text);
            margin: 0; padding: 28px 20px 20px 20px; display: flex; flex-direction: column; gap: 24px;
            height: 100vh; overflow: hidden; touch-action: none; overscroll-behavior: none;
        }

        /* é¡¶éƒ¨çŠ¶æ€ */
        .header { display: flex; justify-content: space-between; align-items: center; padding: 0 5px; }
        .title { font-size: 24px; font-weight: 800; }
        .badge { font-size: 12px; color: var(--accent); background: rgba(0,122,255,0.1); padding: 4px 10px; border-radius: 12px; font-weight: 600; }
        .badge.online { color: #34c759; background: rgba(52,199,89,0.1); }
        .badge.offline { color: #ff3b30; background: rgba(255,59,48,0.1); }

        /* å¡ç‰‡å®¹å™¨ */
        .card { background: var(--card); border-radius: 20px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }

        /* åª’ä½“ä¿¡æ¯ */
        .media-info { text-align: center; margin-bottom: 24px; }
        .song { font-size: 18px; font-weight: 700; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .artist { font-size: 14px; color: var(--sub); }

        /* æ’­æ”¾æ§åˆ¶ */
        .controls { display: flex; justify-content: center; align-items: center; gap: 40px; margin-bottom: 24px; }
        .btn { background: none; border: none; color: var(--text); cursor: pointer; transition: transform 0.1s; display: flex; align-items: center; justify-content: center; }
        .btn:active { transform: scale(0.85); opacity: 0.7; }
        .btn-side { width: 40px; height: 40px; }
        .btn-side svg { width: 28px; height: 28px; fill: currentColor; }
        .btn-play { width: 70px; height: 70px; background: var(--text); color: var(--bg); border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }
        .btn-play svg { width: 32px; height: 32px; fill: currentColor; }

        /* iOS é£æ ¼éŸ³é‡æ¡ */
        .volume-container { 
            display: flex; align-items: center; gap: 12px; 
            background: var(--track); padding: 6px 16px 6px 6px; border-radius: 16px; 
        }
        .vol-btn { 
            width: 36px; height: 36px; border-radius: 12px; background: var(--card); 
            display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.05); 
        }
        .vol-btn svg { width: 18px; height: 18px; fill: var(--sub); }
        
        .slider-wrapper { flex: 1; position: relative; height: 36px; display: flex; align-items: center; }
        input[type=range] {
            -webkit-appearance: none; width: 100%; height: 6px; background-color: var(--track); border-radius: 999px;
            position: relative; z-index: 2; margin: 0; padding: 0; overflow: visible;
        }
        input[type=range]:focus { outline: none; }
        /* ä½¿ç”¨é€æ˜è½¨é“ï¼Œè¿›åº¦ç”±å…ƒç´ èƒŒæ™¯ (linear-gradient) ç»˜åˆ¶ */
        input[type=range]::-webkit-slider-runnable-track {
            height: 6px; background: transparent; border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 20px; width: 20px; border-radius: 50%; background: var(--card);
            box-shadow: 0 2px 6px rgba(0,0,0,0.18); cursor: pointer; -webkit-appearance: none; margin-top: -7px;
        }
        input[type=range]::-moz-range-track { height: 6px; background: transparent; border-radius: 3px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: var(--card); box-shadow: 0 2px 6px rgba(0,0,0,0.18); }

        /* æ–‡æœ¬è¾“å…¥ (IM é£æ ¼) */
        .input-area { 
            display: flex; 
            gap: 10px; 
            align-items: stretch;
        }
        .input-area textarea {
            flex: 1;
        }
        .input-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 50px;
        }
        textarea {
            min-height: 100px; max-height: 40vh; border: none; background: var(--track); border-radius: 18px;
            padding: 12px 16px; font-size: 16px; color: var(--text); resize: none; font-family: inherit; overflow: auto;
            line-height: 1.4;
        }
        textarea:focus { outline: none; background: rgba(142,142,147, 0.15); }
        .send-btn, .clip-btn {
            width: 50px; height: 50px; border-radius: 12px; border: none;
            color: white; display: flex; align-items: center; justify-content: center; 
            box-shadow: 0 4px 10px rgba(0,122,255,0.3);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 20px;
            font-weight: bold;
        }
        .send-btn {
            background: var(--accent);
        }
        .send-btn:active { transform: scale(0.95); opacity: 0.8; }
        .clip-btn {
            background: #34c759;
        }
        .clip-btn:active { transform: scale(0.95); opacity: 0.8; }

        /* åº•éƒ¨åŠŸèƒ½ç½‘æ ¼ */
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
        .tile {
            background: var(--card); border-radius: 16px; height: 90px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 10px; font-size: 13px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            position: relative; overflow: hidden;
        }
        .tile:active { transform: scale(0.96); background: var(--track); }
        .tile-icon { font-size: 28px; }
        .danger { color: var(--danger); }
        
        /* ä¸Šä¼ åŒº */
        .upload { 
            position: sticky; bottom: 20px; z-index: 6; overflow: hidden;
            border: 2px dashed var(--sub); border-radius: 16px; padding: 12px;
            text-align: center; font-size: 14px; color: var(--sub); opacity: 0.9; background: rgba(255,255,255,0.02);
        }
        .upload input { position: absolute; top:0; left:0; width:100%; height:100%; opacity:0; }
        .tile .progress {
            position: absolute; left: 0; top: 0; bottom: 0; width: 0%; z-index: 0;
            background: rgba(0,122,255,0.12); transition: width linear;
        }
        .tile > * { z-index: 1; }

        /* æ¨¡æ€æ¡†æ ·å¼ */
        .modal-backdrop {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.4); z-index: 100; animation: fadeIn 0.2s ease-out;
        }
        .modal-backdrop.show { display: block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .modal {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--card); border-radius: 20px; padding: 24px; max-width: 90%; width: 320px;
            z-index: 101; animation: popIn 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }
        .modal.show { display: block; }
        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.9); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .modal-header { font-size: 18px; font-weight: 700; margin-bottom: 16px; text-align: center; }
        .modal-content {
            background: var(--track); border-radius: 12px; padding: 16px;
            margin-bottom: 20px; max-height: 40vh; overflow-y: auto; word-break: break-all;
            font-size: 14px; line-height: 1.5; color: var(--text);
        }

        .modal-buttons { display: flex; gap: 12px; }
        .modal-btn {
            flex: 1; padding: 12px 16px; border: none; border-radius: 12px;
            font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;
        }
        .modal-btn-primary {
            background: var(--accent); color: white; box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }
        .modal-btn-primary:active { transform: scale(0.95); opacity: 0.8; }
        .modal-btn-secondary {
            background: var(--track); color: var(--text);
        }
        .modal-btn-secondary:active { background: rgba(0, 0, 0, 0.1); }
    </style>
</head>
<body>

    <div class="header">
        <div class="title">Bealink</div>
        <div style="display: flex; gap: 12px; align-items: center;">
            <div class="badge" id="deviceStatus">è®¾å¤‡åœ¨çº¿</div>
            <a href="/setting" style="font-size: 12px; color: var(--accent); text-decoration: none; padding: 4px 10px; border-radius: 12px; background: rgba(0,122,255,0.1); font-weight: 600;">è®¾ç½®</a>
        </div>
    </div>

    <!-- åª’ä½“å¡ç‰‡ -->
    <div class="card">
        <div class="media-info">
            <div class="song" id="mTitle">åª’ä½“æ§åˆ¶</div>
            <div class="artist" id="mArtist"></div>
        </div>

        <div class="controls">
            <button class="btn btn-side" onclick="api('/media/prev')">
                <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
            </button>
            <button class="btn btn-play" id="playBtn" onclick="api('/media/play')">
                <!-- åŒæ—¶å±•ç¤ºæ’­æ”¾ä¸æš‚åœå›¾æ ‡ï¼ˆå¤šåŠŸèƒ½æŒ‰é’®ï¼‰ï¼Œå‰ç«¯ä¸å†æ ¹æ®çŠ¶æ€åˆ‡æ¢ -->
                
                <svg viewBox="0 0 24 24" style="margin-right:6px"><path d="M8 5v14l11-7z"/></svg>
                <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
            <button class="btn btn-side" onclick="api('/media/next')">
                <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
            </button>
        </div>

        <!-- éŸ³é‡æ¡ (æ‹–æ‹½ä¼˜åŒ–) -->
        <div class="volume-container">
            <button class="vol-btn" onclick="setVolumeZero()">
                <svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-8-7.27-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
            </button>
            <div class="slider-wrapper">
                <input type="range" id="volSlider" min="0" max="100" value="0" oninput="onVolInput(this)" onchange="onVolChange(this)">
            </div>
            <div style="min-width: 45px; text-align: center; font-weight: 600; font-size: 14px; color: var(--text);" id="volPercent">0%</div>
            <button class="vol-btn" onclick="stepVol(5)">
                <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
            </button>
        </div>
    </div>

    <!-- æ–‡æœ¬è¾“å…¥ -->
    <div class="card" style="padding: 20px;">
        <div style="display: flex; align-items: stretch; height: 110px; gap: 10px; margin-top: 10px;">
            
            <textarea id="txt" placeholder="è¾“å…¥æ–‡å­—å‘é€æˆ–æ˜¯å¤åˆ¶..." 
                style="flex: 1; border: none; border-radius: 14px; padding: 12px; background: var(--input-bg); color: var(--text); resize: none; font-size: 16px; font-family: inherit; outline: none; box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);"></textarea>

            <div style="width: 64px; display: flex; flex-direction: column; gap: 8px;">
                
                <button onclick="sendText()" style="flex: 1; border: none; border-radius: 12px; background: #007AFF; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,122,255,0.3); transition: transform 0.1s;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </button>

                <button onclick="sendToClipboard()" style="flex: 1; border: none; border-radius: 12px; background: #34C759; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(52,199,89,0.3); transition: transform 0.1s;">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                </button>
                
            </div>
        </div>
    </div>

    <!-- åŠŸèƒ½åŒº -->
    <div class="grid">
        <div class="tile" onclick="api('/monitor')">
            <span class="tile-icon">ğŸ–¥ï¸</span>
            <span>æ¯å±</span>
        </div>
        <div class="tile" id="sleepTile" onclick="toggleCountdown('sleep', this)">
            <span class="tile-icon">ğŸŒ™</span>
            <span>ç¡çœ </span>
        </div>
        <div class="tile danger" id="shutdownTile" onclick="toggleCountdown('shutdown', this)">
            <span class="tile-icon">â­•</span>
            <span>å…³æœº</span>
        </div>
        <div class="tile" id="pullClipTile" onclick="pullClipboard()">
            <span class="tile-icon">ğŸ“‹</span>
            <span>æ‹‰å–å‰ªåˆ‡æ¿</span>
        </div>
    </div>

    <div class="upload">
        ğŸ“¤ ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡åˆ°å‰ªè´´æ¿
        <input type="file" accept="image/*" onchange="uploadImage(this)">
    </div>

    <!-- æ‹‰å–å‰ªåˆ‡æ¿å¼¹çª— -->
    <div class="modal-backdrop" id="clipboardModal"></div>
    <div class="modal" id="clipboardContent">
        <div class="modal-header">ç”µè„‘å‰ªåˆ‡æ¿å†…å®¹</div>
        <div class="modal-content" id="clipboardText"></div>
        <div class="modal-buttons">
            <button class="modal-btn modal-btn-secondary" onclick="closeClipboardModal()">å–æ¶ˆ</button>
            <button class="modal-btn modal-btn-primary" onclick="confirmCopyClipboard()">ç¡®è®¤å¤åˆ¶</button>
        </div>
    </div>

    <script>
        // çŠ¶æ€é”ï¼šç”¨æˆ·æ‹–æ‹½æ—¶æš‚åœè½®è¯¢æ›´æ–°
        let isDragging = false;
        let lastVol = -1;
        let volumePollInterval = null;
        let deviceOnline = true; // è®¾å¤‡åœ¨çº¿çŠ¶æ€
        let consecutiveFailures = 0; // è¿ç»­å¤±è´¥æ¬¡æ•°
        const MAX_FAILURES = 2; // è¿ç»­å¤±è´¥2æ¬¡åæ ‡è®°ä¸ºç¦»çº¿
        
        // WebSocket è¿æ¥
        let wsSocket = null;
        let wsReconnectTimer = null;
        let wsHeartbeatTimer = null;
        const WS_RECONNECT_DELAY = 3000; // 3ç§’åé‡è¿
        const WS_HEARTBEAT_INTERVAL = 2000; // 10ç§’å‘é€ä¸€æ¬¡å¿ƒè·³ï¼ˆpingï¼‰
        let lastPongTime = Date.now();

        async function api(url) {
            if(navigator.vibrate) navigator.vibrate(10);
            try { await fetch(url); syncStatus(); } catch(e){}
        }

        // éŸ³é‡é€»è¾‘
        let debounceTimer;
        
        // æ‹–æ‹½ä¸­ï¼šåªå‘é€è¯·æ±‚ï¼Œä¸æ›´æ–°UI
        function onVolInput(el) {
            isDragging = true;
            if(debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                fetch('/volume/set?val=' + el.value);
            }, 100); // 100ms èŠ‚æµ
            // è§†è§‰ä¸Šå®æ—¶æ›´æ–°è¿›åº¦
            updateRangeBackground(el);
        }

        // æ‹–æ‹½ç»“æŸï¼šç«‹å³å‘é€ï¼Œç„¶åæŸ¥è¯¢ä¸€æ¬¡éŸ³é‡ï¼ˆç¡®ä¿ UI åŒæ­¥ï¼‰
        function onVolChange(el) {
            fetch('/volume/set?val=' + el.value);
            setTimeout(() => { 
                isDragging = false;
                // æ‹–æ‹½å®ŒæˆåæŸ¥è¯¢ä¸€æ¬¡éŸ³é‡ï¼Œç¡®ä¿ UI æ˜¾ç¤ºçš„æ˜¯å®é™…å€¼
                fetchVolumeWithRetry(2, 200);
            }, 500);
            updateRangeBackground(el);
        }

        // æ­¥è¿›éŸ³é‡
        function stepVol(delta) {
            const el = document.getElementById('volSlider');
            let v = parseInt(el.value) + delta;
            if (v>100) v=100; if (v<0) v=0;
            el.value = v;
            onVolChange(el);
        }

        // æ–‡æœ¬å‘é€
        async function sendText() {
            const el = document.getElementById('txt');
            if(!el.value) return;
            await fetch('/text', {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: 'text=' + encodeURIComponent(el.value)
            });
            el.value = '';
        }

        // æ–‡æœ¬å‘é€åˆ°ç”µè„‘å‰ªåˆ‡æ¿
        async function sendToClipboard() {
            const el = document.getElementById('txt');
            if(!el.value) {
                alert('è¯·å…ˆè¾“å…¥æ–‡å­—');
                return;
            }
            try {
                const response = await fetch('/clip', {
                    method: 'POST',
                    body: el.value
                });
                if (response.ok) {
                    alert('å·²å¤åˆ¶åˆ°ç”µè„‘å‰ªåˆ‡æ¿');
                    el.value = '';
                } else {
                    alert('å¤åˆ¶å¤±è´¥');
                }
            } catch (err) {
                alert('å‘é€å¤±è´¥: ' + err.message);
            }
        }

        // å›¾ç‰‡ä¸Šä¼ 
        async function uploadImage(el) {
            const file = el.files[0];
            if(!file) return;
            const data = new FormData();
            data.append('image', file);
            await fetch('/upload/image', { method: 'POST', body: data });
            el.value = '';
            alert('å›¾ç‰‡å·²å‘é€');
        }

        // å­˜å‚¨å½“å‰å‰ªåˆ‡æ¿å†…å®¹ï¼ˆç”¨äºç¡®è®¤å¤åˆ¶æ—¶ä½¿ç”¨ï¼‰
        let currentClipboardData = '';

        // ç¬¬ä¸€æ­¥ï¼šæ‹‰å–å‰ªåˆ‡æ¿å†…å®¹ï¼Œå¼¹å‡ºæ¨¡æ€æ¡†
        async function pullClipboard() {
            try {
                const resp = await fetch('/getclip', { cache: 'no-store' });
                if (!resp.ok) throw new Error('è·å–å‰ªåˆ‡æ¿å¤±è´¥: ' + resp.status);
                const text = await resp.text();
                if (!text) { alert('å‰ªåˆ‡æ¿ä¸ºç©ºæˆ–éæ–‡æœ¬å†…å®¹'); return; }
                
                // ä¿å­˜å†…å®¹å¹¶æ˜¾ç¤ºæ¨¡æ€æ¡†
                currentClipboardData = text;
                showClipboardModal(text);
            } catch (err) {
                alert('æ‹‰å–å‰ªåˆ‡æ¿å¤±è´¥: ' + err.message);
            }
        }

        // æ˜¾ç¤ºæ¨¡æ€æ¡†
        function showClipboardModal(text) {
            document.getElementById('clipboardText').innerText = text;
            document.getElementById('clipboardModal').classList.add('show');
            document.getElementById('clipboardContent').classList.add('show');
        }

        // å…³é—­æ¨¡æ€æ¡†
        function closeClipboardModal() {
            document.getElementById('clipboardModal').classList.remove('show');
            document.getElementById('clipboardContent').classList.remove('show');
            currentClipboardData = '';
        }

        // ç¬¬äºŒæ­¥ï¼šç”¨æˆ·ç‚¹å‡»"ç¡®è®¤å¤åˆ¶"ï¼Œæ­¤æ—¶æ•°æ®å·²åœ¨æœ¬åœ°ï¼Œå¤åˆ¶æ˜¯åŒæ­¥çš„
        function confirmCopyClipboard() {
            const text = currentClipboardData;
            let success = false;

            // æ–¹æ¡ˆ 1ï¼šå°è¯•ç°ä»£ Clipboard APIï¼ˆåŒæ­¥è°ƒç”¨ï¼Œä¸ awaitï¼‰
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).catch(() => {
                    // å¦‚æœå¤±è´¥ï¼Œå°è¯•å¤‡é€‰æ–¹æ¡ˆï¼ˆåœ¨è¿™ä¸ªå›è°ƒä¸­å·²ç»ç¦»å¼€ç”¨æˆ·æ¿€æ´»æ ˆï¼Œæ‰€ä»¥ä¼šå¤±è´¥ï¼Œä½†ä¸è¦ç´§ï¼‰
                    tryFallbackCopy(text);
                });
                success = true;
            } else {
                // ç›´æ¥ä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ
                success = tryFallbackCopy(text);
            }

            if (success) {
                // æ˜¾ç¤ºæˆåŠŸæç¤º
                const contentDiv = document.getElementById('clipboardText');
                const originalText = contentDiv.innerText;
                contentDiv.style.color = '#34c759';
                contentDiv.innerText = 'âœ“ å¤åˆ¶æˆåŠŸï¼';
                setTimeout(() => {
                    closeClipboardModal();
                }, 600);
            }
        }

        // å¤‡é€‰æ–¹æ¡ˆï¼šä½¿ç”¨ readonly textarea + execCommandï¼ˆåŒæ­¥æ‰§è¡Œï¼Œç¬¦åˆæµè§ˆå™¨è¦æ±‚ï¼‰
        function tryFallbackCopy(text) {
            try {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.setAttribute('readonly', '');
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                ta.style.top = '-9999px';
                document.body.appendChild(ta);
                ta.focus();
                if (typeof ta.setSelectionRange === 'function') {
                    ta.setSelectionRange(0, 9999);
                } else {
                    ta.select();
                }
                const ok = document.execCommand('copy');
                document.body.removeChild(ta);
                return ok;
            } catch (e) {
                console.error('Fallback copy failed:', e);
                return false;
            }
        }

        // æ›´æ–°è®¾å¤‡åœ¨çº¿çŠ¶æ€æ˜¾ç¤º
        function updateDeviceStatus(isOnline) {
            const statusEl = document.getElementById('deviceStatus');
            if (!statusEl) return;
            
            // åªæœ‰å½“çŠ¶æ€çœŸæ­£æ”¹å˜æ—¶æ‰æ›´æ–°
            if (deviceOnline === isOnline) return;
            
            deviceOnline = isOnline;
            if (isOnline) {
                statusEl.textContent = 'è®¾å¤‡åœ¨çº¿';
                statusEl.className = 'badge online';
            } else {
                statusEl.textContent = 'è®¾å¤‡ä¸åœ¨çº¿';
                statusEl.className = 'badge offline';
            }
        }
        
        // è¿æ¥ WebSocketï¼ˆç”¨äºæ—¥å¿—å’Œåœ¨çº¿çŠ¶æ€æ£€æµ‹ï¼‰
        function connectWebSocket() {
            // æ„å»º WebSocket URL
            const wsScheme = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsURL = `${wsScheme}//${window.location.host}/ws/logs`;
            
            try {
                wsSocket = new WebSocket(wsURL);
                
                wsSocket.onopen = function(event) {
                    console.log('WebSocket è¿æ¥å·²æ‰“å¼€');
                    // WebSocket è¿æ¥æˆåŠŸï¼Œè®¾å¤‡åœ¨çº¿
                    consecutiveFailures = 0;
                    lastPongTime = Date.now();
                    updateDeviceStatus(true);
                    // æ¸…é™¤é‡è¿å®šæ—¶å™¨
                    if (wsReconnectTimer) {
                        clearTimeout(wsReconnectTimer);
                        wsReconnectTimer = null;
                    }
                    // åœæ­¢ HTTP è½®è¯¢ï¼ˆå› ä¸º WebSocket å·²è¿æ¥ï¼‰
                    stopHttpVolumePoll();
                    // å¯åŠ¨å¿ƒè·³æ£€æµ‹
                    startHeartbeat();
                };
                
                wsSocket.onmessage = function(event) {
                    // æ”¶åˆ°æ¶ˆæ¯è¯´æ˜è¿æ¥æ­£å¸¸ï¼Œåªæ›´æ–°æ—¶é—´æˆ³ï¼Œé¿å…é¢‘ç¹ DOM æ“ä½œ
                    lastPongTime = Date.now();
                    consecutiveFailures = 0;
                    // è®¾å¤‡åœ¨çº¿çŠ¶æ€ç”± onopen å’Œå¿ƒè·³æ£€æµ‹ç»´æŠ¤ï¼Œä¸åœ¨æ¶ˆæ¯å¤„ç†ä¸­æ›´æ–°
                };
                
                wsSocket.onclose = function(event) {
                    console.log('WebSocket è¿æ¥å·²å…³é—­:', event);
                    wsSocket = null;
                    stopHeartbeat();
                    // WebSocket æ–­å¼€ï¼Œç«‹å³æ ‡è®°ä¸ºç¦»çº¿
                    updateDeviceStatus(false);
                    // å¯åŠ¨ HTTP è½®è¯¢ä½œä¸ºå¤‡ç”¨æ£€æµ‹æ–¹å¼
                    startHttpVolumePoll();
                    // å°è¯•é‡è¿
                    if (wsReconnectTimer) {
                        clearTimeout(wsReconnectTimer);
                    }
                    wsReconnectTimer = setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
                };
                
                wsSocket.onerror = function(error) {
                    console.error('WebSocket é”™è¯¯:', error);
                    stopHeartbeat();
                    // WebSocket é”™è¯¯ï¼Œæ ‡è®°ä¸ºç¦»çº¿
                    updateDeviceStatus(false);
                    // å¯åŠ¨ HTTP è½®è¯¢ä½œä¸ºå¤‡ç”¨
                    startHttpVolumePoll();
                };
            } catch (e) {
                console.error('åˆ›å»º WebSocket è¿æ¥å¤±è´¥:', e);
                stopHeartbeat();
                updateDeviceStatus(false);
                // å¯åŠ¨ HTTP è½®è¯¢ä½œä¸ºå¤‡ç”¨
                startHttpVolumePoll();
                // å°è¯•é‡è¿
                if (wsReconnectTimer) {
                    clearTimeout(wsReconnectTimer);
                }
                wsReconnectTimer = setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
            }
        }
        
        // å¯åŠ¨å¿ƒè·³æ£€æµ‹ï¼ˆç”¨äºå¿«é€Ÿæ£€æµ‹è¿æ¥æ–­å¼€ï¼Œå¦‚ç”µè„‘ç¡çœ ï¼‰
        function startHeartbeat() {
            stopHeartbeat(); // å…ˆæ¸…é™¤æ—§çš„å®šæ—¶å™¨
            wsHeartbeatTimer = setInterval(() => {
                if (wsSocket && wsSocket.readyState === WebSocket.OPEN) {
                    // æ£€æŸ¥æ˜¯å¦é•¿æ—¶é—´æ²¡æœ‰æ”¶åˆ°æ¶ˆæ¯ï¼ˆå¯èƒ½è¿æ¥å·²æ–­å¼€ä½†æœªè§¦å‘ oncloseï¼Œå¦‚ç”µè„‘ç¡çœ ï¼‰
                    const timeSinceLastPong = Date.now() - lastPongTime;
                    if (timeSinceLastPong > WS_HEARTBEAT_INTERVAL * 3) {
                        // è¶…è¿‡30ç§’æ²¡æœ‰æ”¶åˆ°ä»»ä½•æ¶ˆæ¯ï¼ˆåŒ…æ‹¬æ—¥å¿—æ¨é€ï¼‰ï¼Œè®¤ä¸ºè¿æ¥å·²æ–­å¼€
                        console.log('WebSocket å¿ƒè·³è¶…æ—¶ï¼Œè¿æ¥å¯èƒ½å·²æ–­å¼€ï¼ˆå¯èƒ½ç”µè„‘å·²ç¡çœ ï¼‰');
                        updateDeviceStatus(false);
                        if (wsSocket) {
                            try {
                                wsSocket.close();
                            } catch (e) {
                                // å¿½ç•¥å…³é—­é”™è¯¯
                            }
                        }
                        // è§¦å‘é‡è¿
                        if (wsReconnectTimer) {
                            clearTimeout(wsReconnectTimer);
                        }
                        wsReconnectTimer = setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
                        return;
                    }
                } else if (wsSocket && wsSocket.readyState !== WebSocket.CONNECTING) {
                    // WebSocket çŠ¶æ€å¼‚å¸¸ï¼Œæ ‡è®°ä¸ºç¦»çº¿
                    updateDeviceStatus(false);
                }
            }, WS_HEARTBEAT_INTERVAL);
        }
        
        // åœæ­¢å¿ƒè·³æ£€æµ‹
        function stopHeartbeat() {
            if (wsHeartbeatTimer) {
                clearInterval(wsHeartbeatTimer);
                wsHeartbeatTimer = null;
            }
        }
        
        // å…³é—­ WebSocket è¿æ¥
        function closeWebSocket() {
            stopHeartbeat();
            if (wsReconnectTimer) {
                clearTimeout(wsReconnectTimer);
                wsReconnectTimer = null;
            }
            if (wsSocket) {
                wsSocket.close();
                wsSocket = null;
            }
        }

        // è·å–éŸ³é‡ä¿¡æ¯å¹¶æ›´æ–°UIï¼ˆæ”¯æŒé‡è¯•æœºåˆ¶ï¼‰
        async function fetchVolumeWithRetry(maxRetries, retryDelay) {
            if (!maxRetries) maxRetries = 3;
            if (!retryDelay) retryDelay = 200;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch('/volume/info', { 
                        method: 'GET',
                        signal: AbortSignal.timeout(2000)
                    });
                    
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status);
                    }
                    
                    const vInfo = await response.json();
                    const slider = document.getElementById('volSlider');
                    const volPercent = document.getElementById('volPercent');
                    if (slider && vInfo.volume !== undefined) {
                        const vol = Math.round(vInfo.volume);
                        slider.value = vol;
                        updateRangeBackground(slider);
                        if (volPercent) {
                            volPercent.textContent = vol + '%';
                        }
                    }
                    console.log('éŸ³é‡æŸ¥è¯¢æˆåŠŸ (å°è¯• ' + attempt + '/' + maxRetries + '): ' + vInfo.volume + '%');
                    return true;
                } catch (e) {
                    console.log('éŸ³é‡æŸ¥è¯¢å¤±è´¥ (å°è¯• ' + attempt + '/' + maxRetries + '):', e.message);
                    if (attempt < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                    }
                }
            }
            console.log('éŸ³é‡æŸ¥è¯¢æœ€ç»ˆå¤±è´¥');
            return false;
        }

        // å¯åŠ¨è®¾å¤‡è¿æ¥ï¼ˆä»…è¿æ¥ WebSocketï¼Œä¸å†è¿›è¡Œå®šæ—¶éŸ³é‡è½®è¯¢ï¼‰
        function startVolumePolling() {
            if (volumePollInterval) return;
            connectWebSocket();
            fetchVolumeWithRetry(3, 200);
        }

        // åœæ­¢è®¾å¤‡è¿æ¥
        function stopVolumePolling() {
            if (volumePollInterval) {
                clearInterval(volumePollInterval);
                volumePollInterval = null;
            }
            closeWebSocket();
        }

        // å¯åŠ¨éŸ³é‡è½®è¯¢ï¼ˆä»…å½“ WebSocket ä¸å¯ç”¨æ—¶ï¼‰
        function startHttpVolumePoll() {
            if (volumePollInterval || (wsSocket && wsSocket.readyState === 1)) {
                return;
            }
            fetchVolumeWithRetry(3, 200);
            volumePollInterval = setInterval(function() {
                fetchVolumeWithRetry(3, 200);
            }, 1000);
        }

        // åœæ­¢ HTTP è½®è¯¢
        function stopHttpVolumePoll() {
            if (volumePollInterval) {
                clearInterval(volumePollInterval);
                volumePollInterval = null;
            }
        }

        // å¯åŠ¨
        // è‡ªåŠ¨è°ƒæ•´ textarea é«˜åº¦ï¼Œé¿å…æ¨é€ä¸Šä¼ åŒºå‡ºå±
        function adjustTextarea(el) {
            if(!el) return;
            // æœ€å¤§é«˜åº¦ä¸ºè§†çª—é«˜åº¦çš„æ¯”ä¾‹ï¼Œç¡®ä¿åº•éƒ¨ä¸Šä¼ åŒºå§‹ç»ˆå¯è§
            const maxPx = Math.round(window.innerHeight * 0.30);
            el.style.height = 'auto';
            const newH = Math.min(el.scrollHeight, maxPx);
            el.style.height = newH + 'px';
        }

        const txtEl = document.getElementById('txt');
        if (txtEl) {
            txtEl.addEventListener('input', function(){ adjustTextarea(this); });
            // åœ¨å‘é€åä¹Ÿæ”¶ç¼©å›æœ€å°é«˜åº¦
            const originalSend = sendText;
            sendText = async function(){ await originalSend(); adjustTextarea(txtEl); };
            // åˆå§‹è°ƒæ•´
            window.addEventListener('load', () => adjustTextarea(txtEl));
            window.addEventListener('resize', () => adjustTextarea(txtEl));
        }

        // ä½¿ç”¨èƒŒæ™¯ linear-gradient ç»˜åˆ¶ä¸»é¢˜è‰²è¿›åº¦
        function updateRangeBackground(el) {
            if(!el) return;
            const min = parseFloat(el.min) || 0;
            const max = parseFloat(el.max) || 100;
            const val = parseFloat(el.value) || 0;
            const pct = Math.round((val - min) / (max - min) * 100);
            // ä½¿ç”¨ single background ä¿è¯å…¼å®¹æ€§ï¼šå‰æ™¯ä¸ºä¸»é¢˜è‰²ï¼Œåæ™¯ä¸ºç°è‰²è½¨é“
            el.style.background = `linear-gradient(90deg, var(--accent) ${pct}%, var(--track) ${pct}%)`;
            // åŒæ­¥æ›´æ–°ç™¾åˆ†æ¯”æ˜¾ç¤º
            const volPercent = document.getElementById('volPercent');
            if (volPercent) {
                volPercent.textContent = Math.round(val) + '%';
            }
        }

        // åˆå§‹åŒ–éŸ³é‡æ»‘å—èƒŒæ™¯
        const volEl = document.getElementById('volSlider');
        if (volEl) {
            updateRangeBackground(volEl);
            volEl.addEventListener('input', function(){ updateRangeBackground(this); });
            window.addEventListener('load', () => { 
                updateRangeBackground(volEl); 
                startVolumePolling(); // å¯åŠ¨ WebSocket å’ŒéŸ³é‡è½®è¯¢
            });
            window.addEventListener('resize', () => updateRangeBackground(volEl));
            // é¡µé¢å¸è½½æ—¶åœæ­¢è½®è¯¢å’Œ WebSocket
            window.addEventListener('beforeunload', stopVolumePolling);
            // é¡µé¢éšè—æ—¶ä¹Ÿåœæ­¢ï¼ˆèŠ‚çœèµ„æºï¼‰
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // é¡µé¢éšè—æ—¶ä¸æ–­å¼€ï¼Œåªæ˜¯æš‚åœéƒ¨åˆ†æ›´æ–°
                } else {
                    // é¡µé¢æ˜¾ç¤ºæ—¶ç¡®ä¿è¿æ¥
                    if (!wsSocket || wsSocket.readyState !== WebSocket.OPEN) {
                        connectWebSocket();
                    }
                }
            });
        }

        // å‰ç«¯é™éŸ³ï¼šæŠŠæ»‘å—è®¾ä¸º0å¹¶å‘é€è®¾ç½®è¯·æ±‚
        function setVolumeZero() {
            const el = document.getElementById('volSlider');
            if (!el) return;
            el.value = 0;
            updateRangeBackground(el);
            // è§¦å‘åç«¯è®¾ç½®
            fetch('/volume/set?val=0').catch(()=>{});
            // çŸ­æš‚æš‚åœè½®è¯¢ï¼Œç­‰å¾…æœåŠ¡å™¨ç”Ÿæ•ˆ
            isDragging = true;
            setTimeout(() => { isDragging = false; }, 600);
        }

        // toggleCountdown è°ƒç”¨ /sleep æˆ– /shutdownï¼Œæ”¯æŒ start/cancel
        async function toggleCountdown(kind, el) {
            const path = kind === 'sleep' ? '/sleep' : '/shutdown';
            try {
                const res = await fetch(path);
                const txt = await res.text();
                let data = {};
                try { data = JSON.parse(txt); } catch(e) { data = { status: 'ok' }; }

                const duration = data.duration || 5;
                const status = data.status || 'ok';
                const tile = el;
                let prog = tile.querySelector('.progress');
                if (!prog) {
                    prog = document.createElement('div'); prog.className = 'progress'; tile.appendChild(prog);
                }

                if (status === 'started') {
                            // ä½¿ç”¨åŸºäºç™¾åˆ†æ¯”çš„å®šæ—¶å™¨æ¥æ˜¾ç¤ºå€’è®¡æ—¶è¿›åº¦ï¼ˆé¿å… CSS åŠ¨ç”»å›å¼¹ï¼‰
                            clearInterval(tile._countdownInterval || 0);
                            tile.dataset.counting = '1';
                            prog.style.transition = 'none';
                            prog.style.width = '0%';
                            const startTs = Date.now();
                            const totalMs = duration * 1000;
                            tile._countdownInterval = setInterval(() => {
                                const elapsed = Date.now() - startTs;
                                let pct = Math.round(Math.min(1, elapsed / totalMs) * 100);
                                prog.style.width = pct + '%';
                                if (elapsed >= totalMs) {
                                    clearInterval(tile._countdownInterval);
                                    tile._countdownInterval = 0;
                                    tile.dataset.counting = '';
                                    // ä¿æŒæ»¡æ ¼çŸ­æš‚åå½’é›¶
                                    setTimeout(() => { prog.style.width = '0%'; }, 600);
                                }
                            }, 100);
                } else if (status === 'cancelled') {
                            // å–æ¶ˆå€’è®¡æ—¶ï¼šæ¸…é™¤å®šæ—¶å™¨å¹¶å›åˆ° 0
                            if (tile._countdownInterval) { clearInterval(tile._countdownInterval); tile._countdownInterval = 0; }
                            prog.style.transition = 'width 0.2s linear';
                            prog.style.width = '0%';
                            tile.dataset.counting = '';
                } else if (status === 'executed') {
                            // ç›´æ¥è®¾ç½®ä¸ºæ»¡æ ¼å¹¶åœæ­¢å®šæ—¶å™¨
                            if (tile._countdownInterval) { clearInterval(tile._countdownInterval); tile._countdownInterval = 0; }
                            prog.style.width = '100%';
                            tile.dataset.counting = '';
                            setTimeout(()=>{ prog.style.width='0%'; }, 800);
                }
            } catch (e) {
                console.log('toggle error', e);
            }
        }

        // ä¸è¿›è¡ŒæŒç»­è½®è¯¢ï¼Œé¡µé¢åŠ è½½æ—¶ä¼šè¯»å–ä¸€æ¬¡éŸ³é‡
    </script>
</body>
</html>